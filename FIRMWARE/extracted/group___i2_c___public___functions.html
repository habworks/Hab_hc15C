<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LPC1700CMSIS Standard Peripheral Firmware Library Manual: I2C Public Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>I2C Public Functions<br>
<small>
[<a class="el" href="group___i2_c.html">I2C</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g4f0c228696f1a8b60437241ba9af7455">I2C_Init</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, uint32_t clockrate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes the I2Cx peripheral with specified parameter.  <a href="#g4f0c228696f1a8b60437241ba9af7455"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g761d88cee2fa33f03e1c08c44057fc5b">I2C_DeInit</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">De-initializes the I2C peripheral registers to their default reset values.  <a href="#g761d88cee2fa33f03e1c08c44057fc5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#ge592e1754a5500b03a1bb92d30e04246">I2C_Cmd</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, <a class="el" href="group___l_p_c___types___public___types.html#gc9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a> NewState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable I2C peripheral's operation.  <a href="#ge592e1754a5500b03a1bb92d30e04246"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___l_p_c___types___public___types.html#g67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g102947f62951ca9031674c3df8117352">I2C_MasterTransferData</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, <a class="el" href="struct_i2_c___m___s_e_t_u_p___type.html">I2C_M_SETUP_Type</a> *TransferCfg, <a class="el" href="group___i2_c___public___types.html#gcbdb9912dc18d79d425d9ac7e1333095">I2C_TRANSFER_OPT_Type</a> Opt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transmit and Receive data in master mode.  <a href="#g102947f62951ca9031674c3df8117352"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___l_p_c___types___public___types.html#g67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#gb855dcf9fa8a95da591c532dbb92af31">I2C_SlaveTransferData</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, <a class="el" href="struct_i2_c___s___s_e_t_u_p___type.html">I2C_S_SETUP_Type</a> *TransferCfg, <a class="el" href="group___i2_c___public___types.html#gcbdb9912dc18d79d425d9ac7e1333095">I2C_TRANSFER_OPT_Type</a> Opt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive and Transmit data in slave mode.  <a href="#gb855dcf9fa8a95da591c532dbb92af31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#gaad67181341bcd015c958f7d21420d01">I2C_MasterTransferComplete</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get status of Master Transfer.  <a href="#gaad67181341bcd015c958f7d21420d01"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g6380268c476af8b17b7ef13f05e404d4">I2C_SlaveTransferComplete</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get status of Slave Transfer.  <a href="#g6380268c476af8b17b7ef13f05e404d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g04a15375bbb68c96a97279b192ee7a5a">I2C_SetOwnSlaveAddr</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, <a class="el" href="struct_i2_c___o_w_n_s_l_a_v_e_a_d_d_r___c_f_g___type.html">I2C_OWNSLAVEADDR_CFG_Type</a> *OwnSlaveAddrConfigStruct)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set Own slave address in I2C peripheral corresponding to parameter specified in OwnSlaveAddrConfigStruct.  <a href="#g04a15375bbb68c96a97279b192ee7a5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g268c8c03cf0f006b58d0e9ad8c00e141">I2C_GetLastStatusCode</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#gef7e2d007e73a69844eafebfbc3e6862">I2C_MonitorModeConfig</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, uint32_t MonitorCfgType, <a class="el" href="group___l_p_c___types___public___types.html#gc9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a> NewState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configures functionality in I2C monitor mode.  <a href="#gef7e2d007e73a69844eafebfbc3e6862"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g236d51a39fe46151b144b56f3d5d465a">I2C_MonitorModeCmd</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, <a class="el" href="group___l_p_c___types___public___types.html#gc9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a> NewState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable/Disable I2C monitor mode.  <a href="#g236d51a39fe46151b144b56f3d5d465a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#geef5efb68afc2a65ffa08572d46fd472">I2C_MonitorGetDatabuffer</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get data from I2C data buffer in monitor mode.  <a href="#geef5efb68afc2a65ffa08572d46fd472"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group___l_p_c___types___public___types.html#g39db6982619d623273fad8a383489309">BOOL_8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#ga8f87a55b16bacca9110c11ff285d3f9">I2C_MonitorHandler</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, uint8_t *<a class="el" href="group___i2_c___monitor.html#g97eaba5b61706891a4da114bde40da4d">buffer</a>, uint32_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get data from I2C data buffer in monitor mode.  <a href="#ga8f87a55b16bacca9110c11ff285d3f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#gbdabf69925593fb4a7d93f576fe4818b">I2C_IntCmd</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx, <a class="el" href="group___l_p_c___types___public___types.html#g39db6982619d623273fad8a383489309">Bool</a> NewState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable/Disable interrupt for I2C peripheral.  <a href="#gbdabf69925593fb4a7d93f576fe4818b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#g2a72b0df9f2df2190c02f44bc5de8f0c">I2C_MasterHandler</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General Master Interrupt handler for I2C peripheral.  <a href="#g2a72b0df9f2df2190c02f44bc5de8f0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i2_c___public___functions.html#gd6be7f7f521b9838d05cb033caae68d0">I2C_SlaveHandler</a> (<a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *I2Cx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General Slave Interrupt handler for I2C peripheral.  <a href="#gd6be7f7f521b9838d05cb033caae68d0"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge592e1754a5500b03a1bb92d30e04246"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_Cmd" ref="ge592e1754a5500b03a1bb92d30e04246" args="(LPC_I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Cmd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l_p_c___types___public___types.html#gc9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable I2C peripheral's operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NewState</em>&nbsp;</td><td>New State of I2Cx peripheral's operation </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>none </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00342">342</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g761d88cee2fa33f03e1c08c44057fc5b"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_DeInit" ref="g761d88cee2fa33f03e1c08c44057fc5b" args="(LPC_I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_DeInit           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
De-initializes the I2C peripheral registers to their default reset values. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00309">309</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g268c8c03cf0f006b58d0e9ad8c00e141"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_GetLastStatusCode" ref="g268c8c03cf0f006b58d0e9ad8c00e141" args="(LPC_I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_GetLastStatusCode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="g4f0c228696f1a8b60437241ba9af7455"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_Init" ref="g4f0c228696f1a8b60437241ba9af7455" args="(LPC_I2C_TypeDef *I2Cx, uint32_t clockrate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>clockrate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initializes the I2Cx peripheral with specified parameter. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0</li><li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>clockrate</em>&nbsp;</td><td>Target clock rate value to initialized I2C peripheral (Hz) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00261">261</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gbdabf69925593fb4a7d93f576fe4818b"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_IntCmd" ref="gbdabf69925593fb4a7d93f576fe4818b" args="(LPC_I2C_TypeDef *I2Cx, Bool NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_IntCmd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l_p_c___types___public___types.html#g39db6982619d623273fad8a383489309">Bool</a>&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable/Disable interrupt for I2C peripheral. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be:<ul>
<li>LPC_I2C0</li><li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NewState</em>&nbsp;</td><td>New State of I2C peripheral interrupt in NVIC core should be:<ul>
<li>ENABLE: enable interrupt for this I2C peripheral</li><li>DISABLE: disable interrupt for this I2C peripheral </li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00369">369</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2a72b0df9f2df2190c02f44bc5de8f0c"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_MasterHandler" ref="g2a72b0df9f2df2190c02f44bc5de8f0c" args="(LPC_I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MasterHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
General Master Interrupt handler for I2C peripheral. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be:<ul>
<li>LPC_I2C</li><li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00413">413</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gaad67181341bcd015c958f7d21420d01"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_MasterTransferComplete" ref="gaad67181341bcd015c958f7d21420d01" args="(LPC_I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_MasterTransferComplete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get status of Master Transfer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be:<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Master transfer status, could be:<ul>
<li>TRUE master transfer completed</li><li>FALSE master transfer have not completed yet </li></ul>
</dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l01342">1342</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g102947f62951ca9031674c3df8117352"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_MasterTransferData" ref="g102947f62951ca9031674c3df8117352" args="(LPC_I2C_TypeDef *I2Cx, I2C_M_SETUP_Type *TransferCfg, I2C_TRANSFER_OPT_Type Opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___l_p_c___types___public___types.html#g67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> I2C_MasterTransferData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___m___s_e_t_u_p___type.html">I2C_M_SETUP_Type</a> *&nbsp;</td>
          <td class="paramname"> <em>TransferCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___public___types.html#gcbdb9912dc18d79d425d9ac7e1333095">I2C_TRANSFER_OPT_Type</a>&nbsp;</td>
          <td class="paramname"> <em>Opt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Transmit and Receive data in master mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be:<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TransferCfg</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct_i2_c___m___s_e_t_u_p___type.html" title="Master transfer setup data structure definitions.">I2C_M_SETUP_Type</a> structure that contains specified information about the configuration for master transfer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Opt</em>&nbsp;</td><td>a I2C_TRANSFER_OPT_Type type that selected for interrupt or polling mode. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>SUCCESS or ERROR</dd></dl>
Note:<ul>
<li>In case of using I2C to transmit data only, either transmit length set to 0 or transmit data pointer set to NULL.</li><li>In case of using I2C to receive data only, either receive length set to 0 or receive data pointer set to NULL.</li><li>In case of using I2C to transmit followed by receive data, transmit length, transmit data pointer, receive length and receive data pointer should be set corresponding. </li></ul>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00778">778</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="geef5efb68afc2a65ffa08572d46fd472"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_MonitorGetDatabuffer" ref="geef5efb68afc2a65ffa08572d46fd472" args="(LPC_I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t I2C_MonitorGetDatabuffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get data from I2C data buffer in monitor mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None Note: In monitor mode, the I2C module may lose the ability to stretch the clock (stall the bus) if the ENA_SCL bit is not set. This means that the processor will have a limited amount of time to read the contents of the data received on the bus. If the processor reads the I2DAT shift register, as it ordinarily would, it could have only one bit-time to respond to the interrupt before the received data is overwritten by new data. </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l01297">1297</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga8f87a55b16bacca9110c11ff285d3f9"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_MonitorHandler" ref="ga8f87a55b16bacca9110c11ff285d3f9" args="(LPC_I2C_TypeDef *I2Cx, uint8_t *buffer, uint32_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___l_p_c___types___public___types.html#g39db6982619d623273fad8a383489309">BOOL_8</a> I2C_MonitorHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get data from I2C data buffer in monitor mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None Note: In monitor mode, the I2C module may lose the ability to stretch the clock (stall the bus) if the ENA_SCL bit is not set. This means that the processor will have a limited amount of time to read the contents of the data received on the bus. If the processor reads the I2DAT shift register, as it ordinarily would, it could have only one bit-time to respond to the interrupt before the received data is overwritten by new data. </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l01318">1318</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g236d51a39fe46151b144b56f3d5d465a"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_MonitorModeCmd" ref="g236d51a39fe46151b144b56f3d5d465a" args="(LPC_I2C_TypeDef *I2Cx, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MonitorModeCmd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l_p_c___types___public___types.html#gc9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable/Disable I2C monitor mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NewState</em>&nbsp;</td><td>New State of this function, should be:<ul>
<li>ENABLE: Enable monitor mode.</li><li>DISABLE: Disable monitor mode. </li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l01262">1262</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gef7e2d007e73a69844eafebfbc3e6862"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_MonitorModeConfig" ref="gef7e2d007e73a69844eafebfbc3e6862" args="(LPC_I2C_TypeDef *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MonitorModeConfig           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>MonitorCfgType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___l_p_c___types___public___types.html#gc9a7e9a35d2513ec15c3b537aaa4fba1">FunctionalState</a>&nbsp;</td>
          <td class="paramname"> <em>NewState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures functionality in I2C monitor mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>MonitorCfgType</em>&nbsp;</td><td>Monitor Configuration type, should be:<ul>
<li>I2C_MONITOR_CFG_SCL_OUTPUT: I2C module can 'stretch' the clock line (hold it low) until it has had time to respond to an I2C interrupt.</li><li>I2C_MONITOR_CFG_MATCHALL: When this bit is set to '1' and the I2C is in monitor mode, an interrupt will be generated on ANY address received. </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>NewState</em>&nbsp;</td><td>New State of this function, should be:<ul>
<li>ENABLE: Enable this function.</li><li>DISABLE: Disable this function. </li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l01234">1234</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g04a15375bbb68c96a97279b192ee7a5a"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_SetOwnSlaveAddr" ref="g04a15375bbb68c96a97279b192ee7a5a" args="(LPC_I2C_TypeDef *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SetOwnSlaveAddr           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___o_w_n_s_l_a_v_e_a_d_d_r___c_f_g___type.html">I2C_OWNSLAVEADDR_CFG_Type</a> *&nbsp;</td>
          <td class="paramname"> <em>OwnSlaveAddrConfigStruct</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set Own slave address in I2C peripheral corresponding to parameter specified in OwnSlaveAddrConfigStruct. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>OwnSlaveAddrConfigStruct</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct_i2_c___o_w_n_s_l_a_v_e_a_d_d_r___c_f_g___type.html" title="I2C Own slave address setting structure.">I2C_OWNSLAVEADDR_CFG_Type</a> structure that contains the configuration information for the specified I2C slave address. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l01181">1181</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd6be7f7f521b9838d05cb033caae68d0"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_SlaveHandler" ref="gd6be7f7f521b9838d05cb033caae68d0" args="(LPC_I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SlaveHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
General Slave Interrupt handler for I2C peripheral. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be:<ul>
<li>LPC_I2C0</li><li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00617">617</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6380268c476af8b17b7ef13f05e404d4"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_SlaveTransferComplete" ref="g6380268c476af8b17b7ef13f05e404d4" args="(LPC_I2C_TypeDef *I2Cx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_SlaveTransferComplete           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get status of Slave Transfer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be:<ul>
<li>LPC_I2C0</li><li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Complete status, could be: TRUE/FALSE </dd></dl>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l01359">1359</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb855dcf9fa8a95da591c532dbb92af31"></a><!-- doxytag: member="lpc17xx_i2c.h::I2C_SlaveTransferData" ref="gb855dcf9fa8a95da591c532dbb92af31" args="(LPC_I2C_TypeDef *I2Cx, I2C_S_SETUP_Type *TransferCfg, I2C_TRANSFER_OPT_Type Opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___l_p_c___types___public___types.html#g67a0db04d321a74b7e7fcfd3f1a3f70b">Status</a> I2C_SlaveTransferData           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_p_c___i2_c___type_def.html">LPC_I2C_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>I2Cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s___s_e_t_u_p___type.html">I2C_S_SETUP_Type</a> *&nbsp;</td>
          <td class="paramname"> <em>TransferCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___i2_c___public___types.html#gcbdb9912dc18d79d425d9ac7e1333095">I2C_TRANSFER_OPT_Type</a>&nbsp;</td>
          <td class="paramname"> <em>Opt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Receive and Transmit data in slave mode. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>I2Cx</em>&nbsp;</td><td>I2C peripheral selected, should be<ul>
<li>LPC_I2C0<ul>
<li>LPC_I2C1</li><li>LPC_I2C2 </li></ul>
</li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>TransferCfg</em>&nbsp;</td><td>Pointer to a <a class="el" href="struct_i2_c___s___s_e_t_u_p___type.html" title="Slave transfer setup data structure definitions.">I2C_S_SETUP_Type</a> structure that contains specified information about the configuration for master transfer. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>Opt</em>&nbsp;</td><td>I2C_TRANSFER_OPT_Type type that selected for interrupt or polling mode. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>SUCCESS or ERROR</dd></dl>
Note: The mode of slave's operation depends on the command sent from master on the I2C bus. If the master send a SLA+W command, this sub-routine will use receive data length and receive data pointer. If the master send a SLA+R command, this sub-routine will use transmit data length and transmit data pointer. If the master issue an repeat start command or a stop command, the slave will enable an time out condition, during time out condition, if there's no activity on I2C bus, the slave will exit, otherwise (i.e. the master send a SLA+R/W), the slave then switch to relevant operation mode. The time out should be used because the return status code can not show difference from stop and repeat start command in slave operation. In case of the expected data length from master is greater than data length that slave can support:<ul>
<li>In case of reading operation (from master): slave will return I2C_I2DAT_IDLE_CHAR value.</li><li>In case of writing operation (from master): slave will ignore remain data from master. </li></ul>

<p>Definition at line <a class="el" href="lpc17xx__i2c_8c_source.html#l00990">990</a> of file <a class="el" href="lpc17xx__i2c_8c_source.html">lpc17xx_i2c.c</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jun 7 14:59:34 2011 for LPC1700CMSIS Standard Peripheral Firmware Library Manual by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
